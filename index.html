<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Text Restorer</title>
  <style>
    textarea { width: 100%; height: 150px; }
    #output { margin-top: 20px; white-space: pre-wrap; font-family: monospace; }
  </style>
</head>
<body>
  <h3> –í–≤–µ–¥—ñ—Ç—å –ø–æ—à–∫–æ–¥–∂–µ–Ω–∏–π —Ç–µ–∫—Å—Ç:</h3>
  <textarea id="inputText"></textarea>
  <br><button onclick="restoreText()">üîç –í—ñ–¥–Ω–æ–≤–∏—Ç–∏ —Ç–µ–∫—Å—Ç</button>

  <div id="output"></div>

  <script>
    let output = "";
const DICT = [
  // –í—Å—ñ —Å–ª–æ–≤–∞ –∑ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—É —Ç–∞ —Ç–µ—Å—Ç—É –¥–ª—è —Å–∞–º–æ–ø–µ—Ä–µ–≤—ñ—Ä–∫–∏
  "Alice","was","beginning","to","get","very","tired","of","sitting","by","her","sister","on","the","and",
  "having","nothing","do","once","or","twice","she","had","peeped","into","book","reading","but","it","no",
  "pictures","conversations","in","what","is","use","a","thought","without", "Hello", "world", "World", "book", "bank"
];


function countLetters(str) {
  const count = {};
  for (const ch of str.toLowerCase()) {
    if (ch >= 'a' && ch <= 'z') count[ch] = (count[ch] || 0) + 1;
  }
  return count;
}

// –§—É–Ω–∫—Ü—ñ—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏, —á–∏ —Å–ª–æ–≤–æ –º–æ–∂–Ω–∞ –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏ –∑ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—É
function similarEnough(segment, word) {
  if (segment.length !== word.length) return false;
  const segLetters = segment.replace(/\*/g, "").split("");
  const wordLetters = word.split("");

  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞: —á–∏ —É—Å—ñ –ª—ñ—Ç–µ—Ä–∏ —Å–µ–≥–º–µ–Ω—Ç–∞ —î —É —Å–ª–æ–≤—ñ
  return segLetters.every(ch => wordLetters.includes(ch));
}

function matchesWithStars(segment, word) {
  if (segment.length !== word.length) return false;

  const segCount = countLetters(segment);
  const wordCount = countLetters(word);
  const stars = segment.split("*").length - 1;

  let deficit = 0;
  for (const ch in wordCount) {
    const sc = segCount[ch] || 0;
    deficit += Math.max(0, wordCount[ch] - sc);
  }
  return deficit === stars;
}

// –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç–µ–π –ª—ñ—Ç–µ—Ä –Ω–∞ –æ–¥–Ω–∞–∫–æ–≤–∏—Ö –ø–æ–∑–∏—Ü—ñ—è—Ö
function calculatePositionMatches(segment, word) {
    let matches = 0;
    for (let i = 0; i < segment.length; i++) {
        if (segment[i] !== '*' && segment[i].toLowerCase() === word[i].toLowerCase()) {
            matches++;
        }
    }
    return matches;
}

// –û—Å–Ω–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è: DP –∑ –º–µ–º–æ—ñ–∑–∞—Ü—ñ—î—é
function matchesExactPositions(segment, word) {
  if (segment.length !== word.length) return false;
  
  for (let i = 0; i < segment.length; i++) {
    if (segment[i] !== '*' && segment[i].toLowerCase() !== word[i].toLowerCase()) {
      return false;
    }
  }
  return true;
}

//  —Ñ—É–Ω–∫—Ü—ñ—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Å–ª—ñ–≤ –∑ –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç–æ–º –ø–æ–∑–∏—Ü—ñ—ó
function restoreWords(input) {
  const n = input.length;
  const memo = new Array(n + 1).fill(null);
  memo[n] = [];

  function dfs(i) {
    if (memo[i] !== null) return memo[i];

    let candidates = [];
    
    for (const word of DICT) {
      const L = word.length;
      const seg = input.slice(i, i + L);
      if (seg.length < L) continue;

      if (matchesWithStars(seg, word) && similarEnough(seg, word)) {
        const rest = dfs(i + L);
        if (rest !== null) {
          candidates.push({
            word,
            rest,
            positionMatches: calculatePositionMatches(seg, word),
            exactMatch: matchesExactPositions(seg, word)
          });
        }
      }
    }

    // –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è —Å–ø–æ—á–∞—Ç–∫—É –∑–∞ —Ç–æ—á–Ω–∏–º–∏ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è–º–∏, –∞ –ø–æ—Ç—ñ–º –∑–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ—Å—Ç—é –ø–æ–∑–∏—Ü—ñ—è–º.
    candidates.sort((a, b) => {
      if (a.exactMatch !== b.exactMatch) {
        return b.exactMatch ? 1 : -1;
      }
      return b.positionMatches - a.positionMatches;
    });

    memo[i] = candidates.length > 0 ? [candidates[0].word, ...candidates[0].rest] : null;
    return memo[i];
  }

  return dfs(0);
}
// –§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Ä–µ—á–µ–Ω—å
function punctuate(words) {
  if (!words || words.length === 0) return "";
  const result = [];
  let current = [];

  const shouldSplit = (i) => {
    const triggers = ["so", "then"];
    return triggers.includes(words[i]);
  };

  for (let i = 0; i < words.length; i++) {
    if (i > 0 && shouldSplit(i)) {
      result.push(current);
      current = [];
    }
    current.push(words[i]);
  }

  if (current.length > 0) result.push(current);

  return result.map(s => s.join(" "));
}

function restoreText() {
   const input = document.getElementById("inputText").value.trim();
  const result = restoreWords(input);
  if (!result){
    document.getElementById("output").textContent = "‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏ —Ç–µ–∫—Å—Ç.";
    return;
  } else {
    document.getElementById("output").textContent = "‚úÖ –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–∏–π —Ç–µ–∫—Å—Ç:\n" + punctuate(result);
  } 
}

</script>
</body>
</html>